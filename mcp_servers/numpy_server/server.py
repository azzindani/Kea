
import sys
from pathlib import Path
# Fix for importing 'shared' module from root when running in JIT mode
root_path = str(Path(__file__).parents[2])
if root_path not in sys.path:
    sys.path.append(root_path)



from mcp.server.fastmcp import FastMCP
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent))
from tools import (
    creation_ops, manip_ops, math_ops, logic_ops, 
    linalg_ops, random_ops, fft_ops, super_ops,
    bitwise_ops, string_ops, set_ops, poly_ops, stat_plus_ops
)
import structlog
from typing import List, Dict, Any, Optional, Union

logger = structlog.get_logger()

# Create the FastMCP server
mcp = FastMCP("numpy_server", dependencies=["numpy", "pandas"])
NumericData = Union[List[float], List[int], str] 

# ==========================================
# 1. Creation
# ==========================================
@mcp.tool()
async def create_array(data: NumericData) -> List[Any]: return await creation_ops.create_array(data)
@mcp.tool()
async def create_zeros(shape: List[int]) -> List[Any]: return await creation_ops.create_zeros(shape)
@mcp.tool()
async def create_ones(shape: List[int]) -> List[Any]: return await creation_ops.create_ones(shape)
@mcp.tool()
async def create_full(shape: List[int], fill_value: Union[float, int]) -> List[Any]: return await creation_ops.create_full(shape, fill_value)
@mcp.tool()
async def arange(start: float, stop: float = None, step: float = 1) -> List[float]: return await creation_ops.arange(start, stop, step)
@mcp.tool()
async def linspace(start: float, stop: float, num: int = 50) -> List[float]: return await creation_ops.linspace(start, stop, num)
@mcp.tool()
async def logspace(start: float, stop: float, num: int = 50, base: float = 10.0) -> List[float]: return await creation_ops.logspace(start, stop, num, base)
@mcp.tool()
async def geomspace(start: float, stop: float, num: int = 50) -> List[float]: return await creation_ops.geomspace(start, stop, num)
@mcp.tool()
async def eye(N: int, M: Optional[int] = None, k: int = 0) -> List[List[float]]: return await creation_ops.eye(N, M, k)
@mcp.tool()
async def identity(n: int) -> List[List[float]]: return await creation_ops.identity(n)
@mcp.tool()
async def diag(v: NumericData, k: int = 0) -> List[Any]: return await creation_ops.diag(v, k)
@mcp.tool()
async def vander(x: List[float], N: Optional[int] = None) -> List[List[float]]: return await creation_ops.vander(x, N)

# ==========================================
# 2. Manipulation
# ==========================================
@mcp.tool()
async def reshape(a: NumericData, newshape: List[int]) -> List[Any]: return await manip_ops.reshape(a, newshape)
@mcp.tool()
async def flatten(a: NumericData) -> List[Any]: return await manip_ops.flatten(a)
@mcp.tool()
async def transpose(a: NumericData, axes: Optional[List[int]] = None) -> List[Any]: return await manip_ops.transpose(a, axes)
@mcp.tool()
async def flip(m: NumericData, axis: Optional[Union[int, List[int]]] = None) -> List[Any]: return await manip_ops.flip(m, axis)
@mcp.tool()
async def roll(a: NumericData, shift: Union[int, List[int]], axis: Optional[Union[int, List[int]]] = None) -> List[Any]: return await manip_ops.roll(a, shift, axis)
@mcp.tool()
async def concatenate(arrays: List[NumericData], axis: int = 0) -> List[Any]: return await manip_ops.concatenate(arrays, axis)
@mcp.tool()
async def stack(arrays: List[NumericData], axis: int = 0) -> List[Any]: return await manip_ops.stack(arrays, axis)
@mcp.tool()
async def vstack(tup: List[NumericData]) -> List[Any]: return await manip_ops.vstack(tup)
@mcp.tool()
async def hstack(tup: List[NumericData]) -> List[Any]: return await manip_ops.hstack(tup)
@mcp.tool()
async def split(ary: NumericData, indices_or_sections: Union[int, List[int]], axis: int = 0) -> List[List[Any]]: return await manip_ops.split(ary, indices_or_sections, axis)
@mcp.tool()
async def tile(A: NumericData, reps: List[int]) -> List[Any]: return await manip_ops.tile(A, reps)
@mcp.tool()
async def repeat(a: NumericData, repeats: Union[int, List[int]], axis: Optional[int] = None) -> List[Any]: return await manip_ops.repeat(a, repeats, axis)
@mcp.tool()
async def unique(ar: NumericData) -> List[Any]: return await manip_ops.unique(ar)
@mcp.tool()
async def trim_zeros(filt: NumericData, trim: str = 'fb') -> List[Any]: return await manip_ops.trim_zeros(filt, trim)
@mcp.tool()
async def pad(array: NumericData, pad_width: List[Any], mode: str = 'constant', constant_values: Any = 0) -> List[Any]: return await manip_ops.pad(array, pad_width, mode, constant_values)

# ==========================================
# 3. Math
# ==========================================
@mcp.tool()
async def add(x1: NumericData, x2: NumericData) -> List[Any]: return await math_ops.add(x1, x2)
@mcp.tool()
async def subtract(x1: NumericData, x2: NumericData) -> List[Any]: return await math_ops.subtract(x1, x2)
@mcp.tool()
async def multiply(x1: NumericData, x2: NumericData) -> List[Any]: return await math_ops.multiply(x1, x2)
@mcp.tool()
async def divide(x1: NumericData, x2: NumericData) -> List[Any]: return await math_ops.divide(x1, x2)
@mcp.tool()
async def power(x1: NumericData, x2: NumericData) -> List[Any]: return await math_ops.power(x1, x2)
@mcp.tool()
async def mod(x1: NumericData, x2: NumericData) -> List[Any]: return await math_ops.mod(x1, x2)
# Functions
@mcp.tool()
async def abs_val(x: NumericData) -> List[Any]: return await math_ops.abs_val(x)
@mcp.tool()
async def sign(x: NumericData) -> List[Any]: return await math_ops.sign(x)
@mcp.tool()
async def exp(x: NumericData) -> List[Any]: return await math_ops.exp(x)
@mcp.tool()
async def log(x: NumericData) -> List[Any]: return await math_ops.log(x)
@mcp.tool()
async def log10(x: NumericData) -> List[Any]: return await math_ops.log10(x)
@mcp.tool()
async def sqrt(x: NumericData) -> List[Any]: return await math_ops.sqrt(x)
@mcp.tool()
async def sin(x: NumericData) -> List[Any]: return await math_ops.sin(x)
@mcp.tool()
async def cos(x: NumericData) -> List[Any]: return await math_ops.cos(x)
@mcp.tool()
async def tan(x: NumericData) -> List[Any]: return await math_ops.tan(x)
@mcp.tool()
async def rad2deg(x: NumericData) -> List[Any]: return await math_ops.rad2deg(x)
@mcp.tool()
async def deg2rad(x: NumericData) -> List[Any]: return await math_ops.deg2rad(x)
@mcp.tool()
async def clip(a: NumericData, a_min: float, a_max: float) -> List[Any]: return await math_ops.clip(a, a_min, a_max)
@mcp.tool()
async def round_val(a: NumericData, decimals: int = 0) -> List[Any]: return await math_ops.round_val(a, decimals)
# Aggregations
@mcp.tool()
async def sum_val(a: NumericData, axis: Optional[int] = None) -> Union[float, List[Any]]: return await math_ops.sum_val(a, axis)
@mcp.tool()
async def prod(a: NumericData, axis: Optional[int] = None) -> Union[float, List[Any]]: return await math_ops.prod(a, axis)
@mcp.tool()
async def cumsum(a: NumericData, axis: Optional[int] = None) -> List[Any]: return await math_ops.cumsum(a, axis)
@mcp.tool()
async def cumprod(a: NumericData, axis: Optional[int] = None) -> List[Any]: return await math_ops.cumprod(a, axis)
@mcp.tool()
async def diff(a: NumericData, n: int = 1, axis: int = -1) -> List[Any]: return await math_ops.diff(a, n, axis)
@mcp.tool()
async def gradient(f: NumericData) -> List[Any]: return await math_ops.gradient(f)
@mcp.tool()
async def cross(a: NumericData, b: NumericData) -> List[Any]: return await math_ops.cross(a, b)

# ==========================================
# 4. Logic
# ==========================================
@mcp.tool()
async def greater(x1: NumericData, x2: NumericData) -> List[Any]: return await logic_ops.greater(x1, x2)
@mcp.tool()
async def less(x1: NumericData, x2: NumericData) -> List[Any]: return await logic_ops.less(x1, x2)
@mcp.tool()
async def equal(x1: NumericData, x2: NumericData) -> List[Any]: return await logic_ops.equal(x1, x2)
@mcp.tool()
async def not_equal(x1: NumericData, x2: NumericData) -> List[Any]: return await logic_ops.not_equal(x1, x2)
@mcp.tool()
async def logical_and(x1: NumericData, x2: NumericData) -> List[Any]: return await logic_ops.logical_and(x1, x2)
@mcp.tool()
async def logical_or(x1: NumericData, x2: NumericData) -> List[Any]: return await logic_ops.logical_or(x1, x2)
@mcp.tool()
async def logical_not(x: NumericData) -> List[Any]: return await logic_ops.logical_not(x)
@mcp.tool()
async def all_true(a: NumericData, axis: Optional[int] = None) -> Union[bool, List[bool]]: return await logic_ops.all_true(a, axis)
@mcp.tool()
async def any_true(a: NumericData, axis: Optional[int] = None) -> Union[bool, List[bool]]: return await logic_ops.any_true(a, axis)
@mcp.tool()
async def where(condition: NumericData, x: Optional[NumericData] = None, y: Optional[NumericData] = None) -> List[Any]: return await logic_ops.where(condition, x, y)
@mcp.tool()
async def argmax(a: NumericData, axis: Optional[int] = None) -> Union[int, List[int]]: return await logic_ops.argmax(a, axis)
@mcp.tool()
async def argmin(a: NumericData, axis: Optional[int] = None) -> Union[int, List[int]]: return await logic_ops.argmin(a, axis)
@mcp.tool()
async def argsort(a: NumericData, axis: int = -1) -> List[Any]: return await logic_ops.argsort(a, axis)
@mcp.tool()
async def sort(a: NumericData, axis: int = -1) -> List[Any]: return await logic_ops.sort(a, axis)
@mcp.tool()
async def searchsorted(a: NumericData, v: NumericData, side: str = 'left') -> List[Any]: return await logic_ops.searchsorted(a, v, side)

# ==========================================
# 5. Linalg
# ==========================================
@mcp.tool()
async def dot(a: NumericData, b: NumericData) -> List[Any]: return await linalg_ops.dot(a, b)
@mcp.tool()
async def matmul(x1: NumericData, x2: NumericData) -> List[Any]: return await linalg_ops.matmul(x1, x2)
@mcp.tool()
async def inner(a: NumericData, b: NumericData) -> List[Any]: return await linalg_ops.inner(a, b)
@mcp.tool()
async def outer(a: NumericData, b: NumericData) -> List[Any]: return await linalg_ops.outer(a, b)
@mcp.tool()
async def kron(a: NumericData, b: NumericData) -> List[Any]: return await linalg_ops.kron(a, b)
@mcp.tool()
async def matrix_power(a: NumericData, n: int) -> List[Any]: return await linalg_ops.matrix_power(a, n)
@mcp.tool()
async def cholesky(a: NumericData) -> List[Any]: return await linalg_ops.cholesky(a)
@mcp.tool()
async def qr_decomp(a: NumericData, mode: str = 'reduced') -> Dict[str, Any]: return await linalg_ops.qr_decomp(a, mode)
@mcp.tool()
async def svd_decomp(a: NumericData, full_matrices: bool = True) -> Dict[str, Any]: return await linalg_ops.svd_decomp(a, full_matrices)
@mcp.tool()
async def eig(a: NumericData) -> Dict[str, Any]: return await linalg_ops.eig(a)
@mcp.tool()
async def norm(x: NumericData, ord: Any = None, axis: Any = None) -> float: return await linalg_ops.norm(x, ord, axis)
@mcp.tool()
async def cond(x: NumericData, p: Any = None) -> float: return await linalg_ops.cond(x, p)
@mcp.tool()
async def det(a: NumericData) -> float: return await linalg_ops.det(a)
@mcp.tool()
async def matrix_rank(M: NumericData) -> int: return await linalg_ops.matrix_rank(M)
@mcp.tool()
async def solve(a: NumericData, b: NumericData) -> List[Any]: return await linalg_ops.solve(a, b)
@mcp.tool()
async def inv(a: NumericData) -> List[Any]: return await linalg_ops.inv(a)
@mcp.tool()
async def pinv(a: NumericData) -> List[Any]: return await linalg_ops.pinv(a)
@mcp.tool()
async def lstsq(a: NumericData, b: NumericData, rcond: str = 'warn') -> Dict[str, Any]: return await linalg_ops.lstsq(a, b, rcond)

# ==========================================
# 6. Random
# ==========================================
@mcp.tool()
async def rand_float(size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_float(size)
@mcp.tool()
async def rand_int(low: int, high: Optional[int] = None, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_int(low, high, size)
@mcp.tool()
async def rand_normal(loc: float = 0.0, scale: float = 1.0, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_normal(loc, scale, size)
@mcp.tool()
async def rand_uniform(low: float = 0.0, high: float = 1.0, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_uniform(low, high, size)
@mcp.tool()
async def rand_choice(a: NumericData, size: Optional[List[int]] = None, replace: bool = True, p: Optional[NumericData] = None) -> List[Any]: return await random_ops.rand_choice(a, size, replace, p)
@mcp.tool()
async def shuffle(x: NumericData) -> List[Any]: return await random_ops.shuffle(x)
@mcp.tool()
async def permutation(x: Union[int, NumericData]) -> List[Any]: return await random_ops.permutation(x)
# Dist
@mcp.tool()
async def rand_beta(a: float, b: float, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_beta(a, b, size)
@mcp.tool()
async def rand_binomial(n: int, p: float, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_binomial(n, p, size)
@mcp.tool()
async def rand_chisquare(df: float, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_chisquare(df, size)
@mcp.tool()
async def rand_gamma(shape: float, scale: float = 1.0, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_gamma(shape, scale, size)
@mcp.tool()
async def rand_poisson(lam: float = 1.0, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_poisson(lam, size)
@mcp.tool()
async def rand_exponential(scale: float = 1.0, size: Optional[List[int]] = None) -> List[Any]: return await random_ops.rand_exponential(scale, size)

# ==========================================
# 7. FFT & Super
# ==========================================
@mcp.tool()
async def fft(a: NumericData, n: Optional[int] = None, axis: int = -1) -> Dict[str, Any]: return await fft_ops.fft(a, n, axis)
@mcp.tool()
async def ifft(a_real: NumericData, a_imag: Optional[NumericData] = None, n: Optional[int] = None, axis: int = -1) -> List[Any]: return await fft_ops.ifft(a_real, a_imag, n, axis)
@mcp.tool()
async def fft2(a: NumericData, s: Optional[List[int]] = None) -> Dict[str, Any]: return await fft_ops.fft2(a, s)
@mcp.tool()
async def fftfreq(n: int, d: float = 1.0) -> List[float]: return await fft_ops.fftfreq(n, d)
@mcp.tool()
async def analyze_array(data: NumericData) -> Dict[str, Any]: return await super_ops.analyze_array(data)
@mcp.tool()
async def matrix_dashboard(data: NumericData) -> Dict[str, Any]: return await super_ops.matrix_dashboard(data)
@mcp.tool()
async def compare_arrays(a: NumericData, b: NumericData) -> Dict[str, Any]: return await super_ops.compare_arrays(a, b)

# ==========================================
# 8. Bitwise (Ultimate)
# ==========================================
@mcp.tool()
async def bitwise_and(x1: NumericData, x2: NumericData) -> List[Any]: return await bitwise_ops.bitwise_and(x1, x2)
@mcp.tool()
async def bitwise_or(x1: NumericData, x2: NumericData) -> List[Any]: return await bitwise_ops.bitwise_or(x1, x2)
@mcp.tool()
async def bitwise_xor(x1: NumericData, x2: NumericData) -> List[Any]: return await bitwise_ops.bitwise_xor(x1, x2)
@mcp.tool()
async def bitwise_not(x: NumericData) -> List[Any]: return await bitwise_ops.bitwise_not(x)
@mcp.tool()
async def left_shift(x1: NumericData, x2: NumericData) -> List[Any]: return await bitwise_ops.left_shift(x1, x2)
@mcp.tool()
async def right_shift(x1: NumericData, x2: NumericData) -> List[Any]: return await bitwise_ops.right_shift(x1, x2)
@mcp.tool()
async def binary_repr(num: int, width: Optional[int] = None) -> str: return await bitwise_ops.binary_repr(num, width)

# ==========================================
# 9. Strings (Ultimate)
# ==========================================
@mcp.tool()
async def char_add(x1: Union[List[str], str], x2: Union[List[str], str]) -> List[str]: return await string_ops.char_add(x1, x2)
@mcp.tool()
async def char_multiply(a: Union[List[str], str], i: int) -> List[str]: return await string_ops.char_multiply(a, i)
@mcp.tool()
async def char_upper(a: Union[List[str], str]) -> List[str]: return await string_ops.char_upper(a)
@mcp.tool()
async def char_lower(a: Union[List[str], str]) -> List[str]: return await string_ops.char_lower(a)
@mcp.tool()
async def char_replace(a: Union[List[str], str], old: str, new: str, count: Optional[int] = None) -> List[str]: return await string_ops.char_replace(a, old, new, count)
@mcp.tool()
async def char_compare_equal(x1: Union[List[str], str], x2: Union[List[str], str]) -> List[bool]: return await string_ops.char_compare_equal(x1, x2)
@mcp.tool()
async def char_count(a: Union[List[str], str], sub: str, start: int = 0, end: Optional[int] = None) -> List[int]: return await string_ops.char_count(a, sub, start, end)
@mcp.tool()
async def char_find(a: Union[List[str], str], sub: str, start: int = 0, end: Optional[int] = None) -> List[int]: return await string_ops.char_find(a, sub, start, end)

# ==========================================
# 10. Sets (Ultimate)
# ==========================================
@mcp.tool()
async def unique_counts(ar: NumericData) -> Dict[str, Any]: return await set_ops.unique_counts(ar)
@mcp.tool()
async def union1d(ar1: NumericData, ar2: NumericData) -> List[Any]: return await set_ops.union1d(ar1, ar2)
@mcp.tool()
async def intersect1d(ar1: NumericData, ar2: NumericData) -> List[Any]: return await set_ops.intersect1d(ar1, ar2)
@mcp.tool()
async def setdiff1d(ar1: NumericData, ar2: NumericData) -> List[Any]: return await set_ops.setdiff1d(ar1, ar2)
@mcp.tool()
async def setxor1d(ar1: NumericData, ar2: NumericData) -> List[Any]: return await set_ops.setxor1d(ar1, ar2)
@mcp.tool()
async def isin(element: NumericData, test_elements: NumericData) -> List[bool]: return await set_ops.isin(element, test_elements)

# ==========================================
# 11. Polynomials (Ultimate)
# ==========================================
@mcp.tool()
async def poly_fit(x: NumericData, y: NumericData, deg: int) -> Dict[str, Any]: return await poly_ops.poly_fit(x, y, deg)
@mcp.tool()
async def poly_val(coef: List[float], x: NumericData) -> List[float]: return await poly_ops.poly_val(coef, x)
@mcp.tool()
async def poly_roots(coef: List[float]) -> List[Any]: return await poly_ops.poly_roots(coef)
@mcp.tool()
async def poly_from_roots(roots: List[float]) -> List[float]: return await poly_ops.poly_from_roots(roots)
@mcp.tool()
async def poly_derivative(coef: List[float], m: int = 1) -> List[float]: return await poly_ops.poly_derivative(coef, m)
@mcp.tool()
async def poly_integrate(coef: List[float], m: int = 1) -> List[float]: return await poly_ops.poly_integrate(coef, m)

# ==========================================
# 12. Stats Plus (Ultimate)
# ==========================================
@mcp.tool()
async def histogram(a: NumericData, bins: Union[int, str] = 10, range: Optional[List[float]] = None) -> Dict[str, Any]: return await stat_plus_ops.histogram(a, bins, range)
@mcp.tool()
async def bincount(x: NumericData, minlength: int = 0) -> List[int]: return await stat_plus_ops.bincount(x, minlength)
@mcp.tool()
async def digitize(x: NumericData, bins: List[float], right: bool = False) -> List[int]: return await stat_plus_ops.digitize(x, bins, right)
@mcp.tool()
async def correlate(a: NumericData, v: NumericData, mode: str = 'valid') -> List[float]: return await stat_plus_ops.correlate(a, v, mode)
@mcp.tool()
async def convolve(a: NumericData, v: NumericData, mode: str = 'full') -> List[float]: return await stat_plus_ops.convolve(a, v, mode)
@mcp.tool()
async def cov(m: NumericData) -> List[List[float]]: return await stat_plus_ops.cov(m)


if __name__ == "__main__":
    mcp.run()