# üö™ API Gateway Service ("The Front Door")

The **API Gateway** is the centralized nerve center of the **Kea v4.0 Autonomous Enterprise Operating System**. It is responsible for routing user intentions, managing the security perimeter, orchestrating asynchronous research jobs, and handling the entire cognitive pipeline lifecycle. It acts as the single point of entry for all external clients, ensuring consistent authentication, rate limiting, and request validation.

## ‚ú® Features

- **Centralized Security**: Unified authentication and authorization using JWT and session cookies.
- **Smart Rate Limiting**: Tiered limiting based on user identity and IP, preventing system abuse via "Sliding Window" algorithm.
- **Microservice Orchestration**: Seamlessly routes requests to specialized services (Orchestrator, MCP Host, RAG, etc.).
- **Asynchronous Job Management**: Handles long-running research tasks with status tracking and result retrieval.
- **Human-in-the-Loop (HITL)**: Provides endpoints for manual interventions and decision-making during research.
- **Protocol Proxying**: Translates public REST API calls into internal service-to-service communication.
- **Production-Ready Observability**: Integrated Prometheus metrics and structured JSON logging.

## üìê Architecture

The Gateway implements a **4-Layer Defense-in-Depth Architecture**, ensuring that only valid, authorized, and safe requests reach the internal service mesh.

1.  **Transport & Security Layer**:
    *   **HSTS & CSP**: Rigid security headers enforced via `SecurityHeadersMiddleware`.
    *   **Sliding Window Rate Limiting**: Managed via `RateLimitMiddleware` using a ZSET-based algorithm (100 req/min burst protect).
    *   **CORS Management**: Dynamically resolved origins via `get_cors_origins()`.
2.  **Identity Layer**:
    *   **Hybrid Authentication**: Supports `JWT` for programmatic access and `HttpOnly Cookies` for browser sessions.
    *   **Token Authority**: The Gateway acts as the central issuer; downstream services trust the injected `X-User-ID` header.
3.  **Application Layer**:
    *   **Route Dispatching**: Polymorphic route modules (Jobs, Graph, Memory, etc.) proxying to specialized upstream services.
    *   **Polymorphic Jobs**: The `/jobs` endpoint handles Research, Synthesis, and Calculation job types.
4.  **Persistence Layer**:
    *   **Event Bus**: Internal service-to-service communication hooks.
    *   **Postgres State**: Used for high-frequency tracking (rate limits, session metrics).

```mermaid
graph TD
    User((User)) -->|HTTP/REST| Gateway[API Gateway (Port 8000)]
    
    subgraph Layers
        Gateway --> Auth[Identity & Security]
        Auth --> Router{Route Dispatcher}
        
        Router -->|/chat/message| Orch[Orchestrator<br/>(Port 8001)]
        Router -->|/tools/call| MCP[MCP Host<br/>(Port 8002)]
        Router -->|/datasets| RAG[RAG Service<br/>(Port 8003)]
        Router -->|/audit/logs| Vault[Vault Service<br/>(Port 8004)]
        Router -->|/jobs| Chronos[Chronos Service<br/>(Port 8006)]
    end
    
    Orch -->|Trigger| Planner
    Chronos -->|Schedule| Queue[Postgres Queue]
```

## üìÅ Codebase Structure

The service is organized into functional modules that isolate security logic from routing and upstream communication.

### üîå Core Components

- **`main.py`**: The application entrypoint. Configures FastAPI, assembles the middleware stack, and mounts all polymorphic routers.
- **`routes/`**: Implementation of API endpoints. These modules serve as "orchestrators" that validate inputs and delegate work.
    - `auth.py`: Identity management, login, registration, and token issuance.
    - `conversations.py`: High-level chat interface, interacting with the Orchestrator's state machine.
    - `jobs.py`: Core research job management, proxying to the Chronos scheduling service.
    - `mcp.py`: Interface for direct tool calls and MCP server management.
    - `interventions.py`: Manages human-in-the-loop pause states and decision points.
    - `system.py`: Service health, configuration exposure, and capability discovery.
    - `artifacts.py`: Interface for uploading/downloading heavy data assets generated by the system.
    - `graph.py`: Visualizations and graph introspection.
    - `llm.py`: Direct LLM interaction endpoints.
    - `memory.py`: Semantic search and memory retrieval interface.
    - `users.py`: User profile and settings management.
- **`middleware/`**: Cross-cutting concerns that process every request before it hits a route.
    - `auth.py`: JWT/Cookie verification and identity injection into the request state.
    - `rate_limit.py`: Sliding-window rate limiting using a shared Postgres backend.
    - `security.py`: CSP, HSTS, and CORS header management.
- **`clients/`**: Highly optimized HTTP/RPC clients for communicating with other Kea services.
    - `orchestrator.py`: Client for the Reasoning/Planning engine.
    - `mcp_client.py`: Client for the Tool Execution host.
    - `rag_service.py`: Client for the Knowledge and Discovery service.
- **`schemas/`**: Pydantic models for request/response validation across the gateway.

## üß† Deep Dive

### 1. Hybrid Rate Limiting Implementation
To prevent "DDoS by Agent" (infinite loops), the Gateway implements a tiered limiting strategy:
- **Algorithm**: Sliding Window (ZSET-based).
- **Backend**: Postgres Unlogged Table for global state, providing high throughput.
- **Fail-Open Logic**: If the database becomes unavailable, the Gateway defaults to allowing requests to prioritize system availability.
- **Key Hierarchy**: Limits are applied to `user_id` if authenticated, falling back to IP address for anonymous traffic.

### 2. Service-to-Service Security & Trust
The Gateway is the **Source of Truth for Identity**. 
- Internal services (Orchestrator, Vault, etc.) do not implement their own authentication logic. Instead, they trust the Gateway-injected `X-User-ID` and `X-Scope` headers.
- Internal communication is managed via a `ServiceRegistry` that can be overridden via environment variables for flexible deployment (e.g., K8s vs. Local).

### 3. Polymorphic Job Lifecycle
The `/jobs` endpoint implements a polymorphic pattern where different `job_type` payloads (Research, Synthesis, Shadow Lab) are validated and routed to the same underlying scheduling mechanism in **Chronos**. This allows for a unified tracking interface regardless of the job's complexity.

## üìö Reference

### API Endpoints

| Category | Endpoint | Method | Description |
|:---------|:---------|:-------|:------------|
| **Auth** | `/api/v1/auth/login` | `POST` | Exchange credentials for a JWT and session cookie. |
| **Jobs** | `/api/v1/jobs` | `POST` | Submit a Research, Synthesis, or Calculation job. |
| **Memory** | `/api/v1/memory/search` | `POST` | Semantic search against the Atomic Facts database. |
| **HITL** | `/api/v1/interventions` | `GET` | List jobs waiting for human decision-making. |
| **Chat** | `/api/v1/conversations` | `POST` | Send a message to the Orchestrator with intent detection. |
| **System** | `/api/v1/system/health` | `GET` | Deep health check of all microservices. |

### Middleware Execution Order
1. **RateLimitMiddleware**: Outermost layer; drops excessive traffic early.
2. **RequestLoggingMiddleware**: Generates `trace_id` for request tracking.
3. **SecurityHeadersMiddleware**: Sets standard security headers (CSP, HSTS).
4. **AuthMiddleware**: Identifies the user and populates `request.state.user`.
5. **CORS (FastAPI Default)**: Innermost layer; handles cross-origin requests.
