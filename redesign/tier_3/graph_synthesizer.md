# Tier 3 Orchestrator (JIT Graph Builder)

## Overview
The Tier 3 Orchestrator translates the conceptual, unstructured requirements generated by Tier 2 into a strict, executable computational graph (Directed Acyclic Graph or DAG). It uses the `Task Decomposition` output to physically assemble nodes that LangGraph or a similar state-machine engine can execute. 

By offloading the "thinking" to Tier 2 and the "executing" to Tier 4, the Orchestrator's sole responsibility is **assembly and dependency routing**.

## Architecture & Flow

```mermaid
---
config:
  layout: dagre
---
flowchart TB
    %% DOWNSTREAM TIER 0 IMPORTS (SCHEMAS)
    subgraph sTier0["Tier 0: Universal Schemas"]
        direction LR
        nSchemaDAG["CompiledDAG Schema (Execution Graph)"]
        nSchemaNode["ExecutableNode Schema"]
    end

    %% Inputs from T4
    subgraph sInput["Incoming Context (Triggered by T4)"]
        nGoal["High-Level Objective"]
        nState["Current Agent State & Constraints"]
    end

    %% DOWNSTREAM TIER 2 IMPORTS (COGNITIVE ENGINES)
    subgraph sT2["Tier 2 Dependencies"]
        direction TB
        nT2Decomp["TaskDecomposer.decompose_goal()<br>(task_decomposition.md)"]
        nT2Curiosity["CuriosityEngine.detect_gaps()<br>(curiosity_engine.md)"]
        nT2WhatIf["SimulationEngine.simulate_outcomes()<br>(what_if_scenario.md)"]
    end

    %% T3 Engine: Graph Assembly
    subgraph sT3["Tier 3: Graph Synthesizer"]
        direction TB
        
        nMapNodes["1. Map T2 sub-tasks to Executable Nodes"]
        nRouteDeps["2. Calculate Dependency Edges (Sequential vs Parallel)"]
        nCompile["3. Compile Prototype LangGraph State DAG"]
        
        nMapNodes --> nRouteDeps --> nCompile
    end

    %% Outputs to T4
    subgraph sOutput["Output to Execution Engine (Tier 4)"]
        nExecDAG["Executable DAG Object"]
        nStateSchema["Generated State Schema (Tier 0 Pydantic)"]
    end

    %% Routing Flow
    nGoal & nState --> nT2Decomp
    nT2Decomp -- "If missing info" --> nT2Curiosity
    nT2Decomp -- "Sub-Task List" --> nMapNodes
    
    nCompile -- "Review Prototype Graph" --> nT2WhatIf
    nT2WhatIf -- "Graph Approved" --> nExecDAG & nStateSchema
    nT2WhatIf -- "Graph Rejected" --> nRouteDeps
    
    nSchemaNode -.->|Formats| nMapNodes
    nSchemaDAG -.->|Formats| nCompile

    %% Styling
    classDef t0 fill:#451A03,stroke:#F59E0B,stroke-width:1px,color:#fff
    classDef t2 fill:#064E3B,stroke:#10B981,stroke-width:2px,color:#fff
    classDef t3 fill:#1E3A8A,stroke:#3B82F6,stroke-width:3px,color:#fff
    classDef t4 fill:#312E81,stroke:#6366F1,stroke-width:1px,color:#fff
    
    class sTier0,nSchemaDAG,nSchemaNode t0
    class sT2,nT2Decomp,nT2Curiosity,nT2WhatIf t2
    class sT3,nMapNodes,nRouteDeps,nCompile t3
    class sOutput,nExecDAG,nStateSchema t4
```

## Key Abstraction Logic
1. **The Black Box of Tier 2**: Notice how Tier 3 does not know *how* `Task Decomposition` works. It simply hands the Goal to Tier 2 and expects an array of logical steps back.
2. **Parallelization**: Tier 3's routing algorithms (`Calculate Dependency Edges`) determine if Step A and Step B rely on each other. If not, it wires the DAG to execute them in parallel, vastly speeding up the agent's real-time OODA loop.
3. **The `What-If` Loop**: Before finalizing a highly complex DAG, Tier 3 passes the compiled prototype back down to Tier 2's `What-If Engine` for a fast offline dry-run to ensure the agent won't trap itself in an infinite loop.
